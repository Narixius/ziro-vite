% it should be about different architectures
\section{Literature Review} % 10 pages

\subsection{Evolution of Web Technologies}

In the early days of framework-based web development, frameworks and technologies like \texttt{Symphony}\footnote{\url{https://symfony.com/}}, \texttt{Laravel}\footnote{\url{https://laravel.com/}} and \texttt{Ruby on Rails}\footnote{\url{https://rubyonrails.org/}} were popular (and still popular), allowing developers to deliver full HTML pages generated on the server. These server-rendered applications have clear benefits. Users receive complete, pre-generated content, making initial page loads quick and ensuring that content was easy for search engines to index. This method effectively addressed early concerns around user experience and web visibility.

However, things changed with the introduction of Single Page Applications (SPAs). SPAs revolutionized development by providing smoother client-side experiences. They shifted the server’s role to mainly delivering static assets while JavaScript managed the content rendering on the client side. This model was attractive due to its improved maintainability and streamlined development. Frameworks like Angular\footnote{\url{https://angularjs.org/}} and later React\footnote{\url{https://react.dev/}} and Vuejs\footnote{\url{https://vuejs.org}} became popular for their client-side rendering (CSR) that delivered a richer and more dynamic user experience.


While SPAs brought many advantages, they also had their challenges. One major weakness of SPAs was their initial page load performance. Since the server only served a minimal HTML content and relied on JavaScript to render content, the time taken for the browser to download and execute the JavaScript bundle impacted the initial load speed. This delay affected user experience and search engine optimization (SEO), as search engines struggled to index content that was rendered dynamically in the browser. To address these issues, SSR frameworks emerged as a practical solution.


\subsection{The Rise of Server-Side Rendering (SSR) Frameworks}

SSR frameworks have changed the landscape of web development, offering benefits that meet the increasing demand for better user experiences and search engine optimization (SEO). These frameworks pre-render content on the server, allowing for faster initial page loads, improved discoverability by search engines, and a smoother user experience. With SSR, the server processes the requests and delivers fully rendered HTML pages to the client, reducing the browser’s responsibility of generating content. This approach has proven valuable as applications have become more interactive and data-heavy.

A significant advantage of SSR frameworks is their positive impact on \texttt{Core Web Vitals}\footnote{\url{https://web.dev/articles/vitals\#core-web-vitals}}, a set of essential metrics used to measure user experience. These include:

\begin{itemize}
	\item \textbf{Largest Contentful Paint (LCP)}: Measures loading performance; SSR improves LCP by ensuring that the initial content loads quickly.
	\item \textbf{First Input Delay (FID)}: Evaluates interactivity; SSR can reduce FID by delivering fully rendered pages that are interactive sooner.
	\item \textbf{Cumulative Layout Shift (CLS)}: Assesses visual stability; SSR reduces layout shifts by ensuring content is structured and rendered on the server before the client receives it.
\end{itemize}

By improving initial page load times, SSR frameworks contribute to better performance in Core Web Vitals, which directly impacts user satisfaction and search engine ranking.

Another benefit of SSR is the ability to generate dynamic Open Graph\footnote{\url{https://ogp.me/}} (OG) tags before the HTML is sent to the user. OG tags are crucial for sharing rich and structured content on social media platforms, enhancing how a web page appears when shared. These tags must exist in the initial response for social media crawlers to read them and display previews accurately. This ensures that shared content looks appealing and informative.

Overall, the evolution from traditional server-rendered pages to SPAs and back to SSR frameworks has shaped modern web development. While SPAs have their benefits, particularly in terms of client-side interactivity and reduced server load, SSR frameworks offer practical solutions for better SEO, improved performance, and enhanced user experience. By implementing SSR, developers can leverage server-side processing to deliver fully rendered pages with optimal loading times, making web applications faster and more accessible.

\subsection{Review of Key SSR Frameworks}

\textbf{Next.js}\footnote{\url{https://nextjs.org/}} has become one of the most widely adopted SSR frameworks within the JavaScript ecosystem. Built around React, it offers a strong set of features, including file-based routing, and advanced built-in SSR capabilities. It provides developers flexibility through hybrid rendering options that combine both SSR and Static Site Generation (SSG). Next.js supports two different routing systems: the Page Router\footnote{\url{https://nextjs.org/docs/pages}} and the App Router\footnote{\url{https://nextjs.org/docs/app}}. The Page Router has limited TypeScript support, which can lead to challenges in maintaining type safety. In contrast, the App Router offers much better TypeScript integration, making it easier for developers to write type-safe code. However, while Next.js shines in out-of-the-box features, it lacks a comprehensive plugin system for extensive customization. This can make large-scale projects more complex as developers need to extend all middleware rules in a single file\footnote{\url{https://nextjs.org/docs/app/building-your-application/routing/middleware}} and create routes manually, resulting in code repetition and in some cases inefficiency.

\textbf{Remix}\footnote{\url{https://remix.run/}} which was made on top of \textbf{React Router}\footnote{\url{https://reactrouter.com/}} by developers behind it, provides a unique approach to handling routing and data fetching. It focuses heavily on nested routing and uses some functions called loaders for data management. This model improves data handling within complex page structures. Remix by introducing delightful APIs for the data fetching flow has improved its developer experience. However, lack of middlewares and having multiple actions on a single route hurts the developer experience. Additionally, Remix doesn't have an easy solution for type-safety, but it works with better developer experience than Next.js in terms of routing and data fetching.


\textbf{Nuxt.js}\footnote{\url{https://nuxt.com}} is the go-to SSR framework for \texttt{Vue.js} applications and offers similar capabilities to Next.js, but tailored for the Vue ecosystem. It has built-in SSR, a modular structure, and supports customizability. In compared to Next.js and Remix, Nuxt offers more APIs to customize the logic behind the app. Of course modifying or extending core logic requires a deep understanding of the framework’s internals but Nuxt has a more comprehensive plugin system than Next.js and Remix which makes it easier to extend the core functionalities. Additionally, Nuxt.js has great support for TypeScript, making it easier for developers to write type-safe code and improve maintainability. In case of developer experience, Nuxt shines!

\textbf{Astro}\footnote{\url{https://astro.build/}} is a newer framework that has gained attention for its support of SSR and hybrid rendering, which blends SSR and Client-Side Rendering (CSR). Its minimal JavaScript footprint helps optimize performance by allowing developers to choose which frameworks to use for different parts of their project. Astro also has first-class support for TypeScript, making it easier for developers to write type-safe code. Although Astro’s modular design provides significant customization, integrating various components can sometimes feel fragmented and may require developers to piece together solutions for a cohesive application. Additionally, Astro offers a revolutionary solution for handling server actions\footnote{\url{https://docs.astro.build/en/guides/actions/}} and data validation, streamlining the process and enhancing developer productivity.
One of the standout features of Astro is its framework-agnostic nature. Developers can write components using React, Vue.js, Svelte, Markdown, etc, allowing for greater flexibility and reusability of existing code. This capability makes Astro an attractive option for teams that work with multiple front-end technologies or are transitioning between frameworks. By supporting a variety of component models, Astro enables developers to leverage the strengths of different frameworks within a single project, optimizing performance and maintainability.


\subsection{The Market Landscape of SSR Frameworks}

The growth of SSR frameworks has been notable in recent years, driven by their potential to enhance user experience and SEO. In the context of market adoption, it's important to understand how frameworks have been received by the development community and the proportion they represent in web development projects.

\textbf{Next.js} stands out as the most widely used SSR framework, supported by its robust integration with React. According to the State of Frontend 2023\footnote{\url{https://2023.stateofjs.com/en-US/libraries/meta-frameworks/}} report, Next.js commands a significant share of the market, with over 56\% of developers who work in web development using it for their SSR needs. The growth can be attributed to its ease of use, stability, and large community, which makes it a good choice for a wide range of projects.

\textbf{Nuxt.js}, continues to be a key player within the Vue.js ecosystem. While its adoption is smaller compared to Next.js, it remains a preferred choice for Vue developers. Its modular architecture and focus on simplifying SSR actions make it an efficient tool for building dynamic, server-rendered applications. According to the State of Frontend 2023 survey, almost 23\% of developers prefer using Nuxt.js, and this percentage grows each year based on the charts. Nuxt.js has a strong presence in the market, with a significant number of developers leveraging its capabilities for SSR projects.

\textbf{Remix}, despite being newer than Next.js and Nuxt.js, has shown rapid growth in popularity, especially among developers seeking greater control over routing and data fetching. The State of Frontend 2023 survey mentioned that while Remix’s adoption is still below of Next.js and Nuxt.js, it has gained significant attention for its modern approach to data management.

\textbf{Astro} has emerged as a promising framework for projects prioritizing performance and reduced JavaScript load. According to the State of Frontend 2023 survey, Astro is used by more developers than Remix, highlighting its growing popularity. Its unique hybrid approach appeals to developers who want the flexibility of combining SSR and CSR efficiently. The use of Astro is increasing, particularly in projects where minimal JavaScript and high performance are key considerations.

\subsection{Why Market Metrics Matter}

Market size or community size alone is not always the most crucial factor when evaluating frameworks. Instead, their progress and the timing of their introduction reveal important insights. For instance, Next.js, launched in 2016, holds a substantial market share due to its established presence. Meanwhile, newer frameworks like Astro, introduced in 2021, have already captured nearly 19\% of the market, reflecting their rapid adoption to developers. This suggests that Astro delivers features that resonate strongly with modern needs.

Rather than selecting a framework outright, we analyze usage metrics and growth trends to identify why these frameworks succeed. This evaluation helps us understand features that can be beneficial to Ziro. For example, Next.js demonstrates reliability with its long-term adoption, but newer frameworks like Astro showcase innovation and efficiency that might inspire Ziro’s design.

\subsection{Evolution of Hosting Solutions and Their Impact on SSR-based Projects}

The growth of server-side rendering (SSR) frameworks has been accompanied by significant advancements in hosting technologies. In the past, web applications were often hosted on virtual private servers (VPS), which, while flexible, required significant manual configuration and maintenance. This setup brought challenges in terms of scalability and performance, making it less suitable for SSR, which demands efficient server processing.

Recently, a shift has occurred with the emergence of modern serverless and edge hosting solutions. Platforms such as Vercel\footnote{\url{https://vercel.com}}, Netlify\footnote{\url{https://netlify.com}}, Cloudflare Pages\footnote{\url{https://pages.cloudflare.com/}}, Deno Deploy\footnote{\url{https://deno.com/deploy}}, and Fly.io\footnote{\url{https://fly.io/deploy}} have transformed how SSR frameworks are deployed. These services offer affordable, scalable hosting that makes it easier for developers to manage applications without worrying about infrastructure complexity.

The idea of running servers "on the edge," closer to the user, has been a game-changer. Platforms like Cloudflare Pages, Deno Deploy, and Fly.io make it possible to execute server-side code from multiple locations worldwide. This approach reduces latency, speeds up load times, and addresses many of the traditional challenges of server-side rendering (SSR), like slow response times and scalability concerns. By being more accessible and cost-effective, edge computing has also made SSR frameworks a go-to solution for developers building fast, efficient web applications.


\subsection{Ziro’s Position: A Foundation for Modern Web Development}

The modern landscape of web development demands frameworks that not only streamline the development process but also empower developers with flexible and powerful tools. While existing frameworks like Next.js, Remix, Nuxt.js, and Astro offer impressive capabilities, they often lack the foundational elements necessary for building comprehensive, feature-rich web applications similar to the advanced content management systems (CMS) seen in the PHP and Laravel ecosystems, such as WordPress\footnote{\url{https://wordpress.org}} and Laravel Nova\footnote{\url{https://nova.laravel.com/}}. This is where Ziro steps in.

\subsection*{The Vision Behind Ziro}

The primary motivation for developing Ziro was to create a framework that enables developers to build applications with the simplicity and extensibility similar to established CMS platforms but within the JavaScript ecosystem. For instance, Laravel Nova is a powerful admin panel for Laravel that integrates seamlessly into the framework, providing a ready-to-use, configurable interface for managing data and content. By installing a plugin or package in Laravel, developers can extend their applications with new functionalities, such as authentication pages or admin dashboards, that are automatically configured through a single configuration file.

Ziro aims to bring this level of seamless integration and extensibility to the JavaScript world, enabling developers to build complex, dynamic web applications without having to reinvent the wheel for common features. With Ziro, adding essential components like authentication pages, administrative panels, or custom workflows should be as simple as including a package and configuring it through a simple config file.

\subsection*{Ziro’s Key Features and Advantages}

\begin{enumerate}
	\item \textbf{Modular Plugin Architecture}: Ziro’s most distinguishing feature is its modular plugin architecture. Unlike existing frameworks that often require developers to build complex middleware or extend core logic from scratch, Ziro allows developers to add new functionalities with pre-built plugins that can be installed and activated with minimal effort. Each plugin in Ziro is designed to integrate seamlessly with the core framework, reducing manual coding and enabling rapid development.

	For example, when a developer wants to add an authentication system or a content management interface, they can install a Ziro plugin that handles all related routes, controllers (loaders/actions), and UI components. This system’s modularity allows developers to customize these features through a single configuration file, hugely reduces the time spent on setup and maintenance.

	\item \textbf{Type Safety and Predictability}: A major pain point with many current frameworks is the difficulty of maintaining type safety across various parts of the application. Ziro addresses this with a type-safe system that extends throughout its routing and data-handling mechanisms. By leveraging TypeScript, Ziro ensures that data passed between components is consistently validated, reducing the risk of runtime errors and making code more predictable. This helps developers build complex applications confidently, knowing that type mismatches will be caught during development rather than after deployment.

	\item \textbf{Comprehensive Configuration Management}: In frameworks like Laravel, configuration management is centralized, allowing developers to control application behavior from a single point. Ziro adopts a similar approach, providing an easy-to-use configuration file where developers can enable or disable plugins, set default values, and manage application settings. This makes it easier to adjust core features and tailor the framework’s behavior to the specific needs of a project.

	\item \textbf{Sequential Data Handling and Flow}: Ziro’s data flow is designed to be both predictable and sequential, ensuring that data loading and state management propagate logically from parent to child routes. This sequential approach facilitates better coordination between different application parts and simplifies managing shared state, making complex data structures easier to handle.

	\item \textbf{Extensibility for Advanced Features}: One of Ziro’s goals is to support the development of advanced features with minimal friction. For instance, when building an application similar to WordPress or Laravel Nova, developers may need to create custom pages or modules that fit within the broader application structure. Ziro’s built-in plugin system and flexible routing make this process straightforward, supporting extensions that behave like native parts of the framework and can extend the Typescript declarations.
\end{enumerate}


\subsection*{The Need for a Comprehensive Foundation}
While frameworks like Next.js, Nuxt.js, Astro or Remix have gained popularity for their robust capabilities, they are often focused on providing a solid base for general-purpose applications. Ziro’s focus is different; it aims to provide a comprehensive, foundational platform that facilitates building developer-friendly tools and applications directly out of the box. With Ziro, developers can focus on building features that matter without having to spend an excessive amount of time setting up repetitive, common components.

\subsection*{Ziro in Context with the Existing Ecosystem}
When compared with other frameworks, Ziro’s position stands out because it bridges the gap between advanced, feature-rich platforms like Laravel and the modern JavaScript ecosystem. While tools like Astro offer efficient rendering and optimized performance, their modular approach can sometimes leave developers piecing together components manually. Ziro’s approach is more comprehensive. It combines powerful, built-in features with the ability to enhance the framework with additional modules without complexity.

The modular and type-safe nature of Ziro brings new opportunities for web developers who seek the fluency of modern JavaScript frameworks while enjoying the satisfaction and extensibility of established CMS platforms. By enabling developers to build feature-rich applications quickly, Ziro opens a new door in the JavaScript ecosystem.

\subsection{Conclusion}

The landscape of web development has seen remarkable evolution, moving from server-rendered content to dynamic client-side applications and now to the hybrid models supported by modern frameworks. Frameworks like Next.js, Nuxt.js, Remix and Astro have cleared the way, each addressing different aspects of performance, SEO, and developer experience. However, as the demand for comprehensive, feature-rich, and scalable applications grows, so too does the need for a framework that combines the flexibility of modern JavaScript tools with the extensibility and ease-of-use found in mature CMS platforms like WordPress and Laravel Nova.

Ziro comes up as a compelling solution in this context. With its type-safe architecture, modular plugin system, and centralized configuration management, it promises to streamline the development of complex applications while promoting rapid deployment and ease of maintenance. Ziro’s approach to sequential data handling, combined with its ability to integrate advanced features seamlessly, positions it uniquely within the ecosystem.

As development teams navigate a choice among existing frameworks, understanding their strengths and limitations is key. While established players like Next.js offer reliability and a standard path, newer frameworks such as Astro showcase the potential for innovative, minimalistic approaches. Ziro, however, sets itself apart by providing new paradigm to developers who need both foundational structure and modular extendibility. It fills the gaps left by existing solutions, providing a practical, developer-centric platform that encourage rapid application development without sacrificing flexibility or depth.

In conclusion, Ziro wants to take the next step in the SSR frameworks era. An inclusive framework that blends the best of JavaScript with the tried-and-tested practices of established web development platforms. Its unique features support developers in building powerful, scalable applications that meet the demands of today's web environment, while remaining adaptable to future technological shifts. As the landscape continues to evolve, frameworks like Ziro will be at the forefront, inspiring a new era of development that is both practical and innovative.

\pagebreak
